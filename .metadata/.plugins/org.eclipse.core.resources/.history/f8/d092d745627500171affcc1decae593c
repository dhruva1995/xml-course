package cscie259.project1.mf;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;


/**
 * A simplified XML parser.  In essence, this class supports a subset
 * of the functionality collectively offered by javax.xml.parsers.SAXParser
 * and javax.xml.parsers.DocumentBuilder.
 *
 * You MAY modify this file.
 *
 * @author  Computer Science E-259
 * @version 8.0
 *
 * @author  YOUR NAME GOES HERE
 **/
public class XMLParser
{
    /**
     * Storage for input file's contents.
     */
    private String data_;


    /**
     * A reference to the currently registered DefaultHandler.
     */
    private DefaultHandler handler_;


    /**
     * Index of our current location in input file's contents.
     */
    private int index_ = 0;


    /**
     * Returns true if the next characters in the stream are the beginning
     * of an element's end tag.
     *
     * @return true iff next characters in the stream are the beginning
     * of an element's end tag
     */
    protected boolean isEndTag()
    {
        return (data_.charAt(index_) == '<')
        && (data_.charAt(index_ + 1) == '/');
    }


    /**
     * Returns true if the next character in the stream is the beginning
     * of an element's start tag.
     *
     * @return true iff next character in the stream is the beginning
     * of an element's start tag
     */
    protected boolean isStartTag()
    {
        return data_.charAt(index_) == '<';
    }


    /**
     * Parses the specified file, if possible, passing SAX events
     * to given handler.
     *
     * @param filename name of file whose contents are to be parsed
     * @param handler  DefaultHandler for SAX events
     */
    public void parse(String filename, DefaultHandler handler)
    {
        // initialize to clean up from any previous parse
        data_ = "";
        index_ = 0;
        handler_ = handler;

        // attempt to open file and read contents into local storage
        try
        {
            File f = new File(filename);
            int filesize = (int) f.length();
            byte[] filebytes = new byte[filesize];
            DataInputStream in = new DataInputStream(new FileInputStream(f));
            in.readFully(filebytes);
            in.close();
            data_ = new String(filebytes);
        }
        catch (IOException E)
        {
            handler_.fatalError(new Exception("Error: could not read file"));
            return;
        }
        
        // parse the document; hopefully there's a root element!
        handler_.startDocument();
        skipConsecutiveWhitespaces();
        //check if file has any non-whitespace character.
		if (index_ != data_.length()) {
			readElement();
		}
        handler_.endDocument();
    }


	/**
	 * Skips over the whitespcae characters at the begining of the give file
	 */
	protected void skipConsecutiveWhitespaces() {
		while (index_ < data_.length() && Character.isWhitespace(data_.charAt(index_))) {
			index_++;
		}
	}


	/**
     * Parses an element and its content.
     */
    protected void readElement()
    {
        if (!isStartTag())
        {
            handler_.fatalError(new RuntimeException("Error: expecting " +
                                                     "start of element"));
            return;
        }

        // parse end tag
        String name = readStartTag();

        // keep reading in more elements and text until an end tag
        // is encountered	
        while (!isEndTag())
        {
            if (isStartTag())
                readElement();
            else
                readText();
        }

        // parse end tag, ensuring it matches most current start tag
        readEndTag(name);
    }    
    

    /**
     * Parses an end tag, ensuring its name matches currently opened
     * element's name.
     *
     * @param checkName currently opened element's name with which
     * end tag should be compared
     */
    protected void readEndTag(String checkName)
    {
        // read starting <
        index_++;

        // read /
        index_++;

        // read name
        String name = readNameOfTag();

        //ETag ::= '<' '/' Name S* '>' 
        //remove S* for above case.
        skipConsecutiveWhitespaces();
        
        if(data_.charAt(index_) != '>') {
        	handler_.fatalError(new RuntimeException("Error : expecting '>' at the last of end tag at " + index_));
        }
        
        // read ending >
        index_++;

        // ensure content is well-formed
        if (!checkName.equals(name))
        {
            handler_.fatalError(new RuntimeException("Error: expecting " +
                                                     "closing tag for " + 
                                                     checkName));
            return;
        }

        // pass this SAX event to handler
        handler_.endElement(name);
    }


    /**
     * Parses a start tag, returning opened element's name.
     *
     * @return name of element
     */
    protected String readStartTag()
    {
        

        // Read starting <
        index_++;

        // Read name
        String name = readNameOfTag();
        // skip white-spaces after name like <name    attr1="value1">
        skipConsecutiveWhitespaces();
        
        Attributes attributes = new Attributes();
        while(data_.charAt(index_) != '>') {
        	//Read attribute name
        	String attributeName = "";
        	while(data_.charAt(index_) != '=' && isNotWhiteSpace()){
            	if(validateCharInName(data_.charAt(index_))){
            		attributeName += data_.charAt(index_);
            		index_++;
            	} else {
            		handler_.fatalError(new RuntimeException("Illegal character inside the name of a attribute at " + index_));
            	}
            }
        	// S* =
            skipConsecutiveWhitespaces();
            if(data_.charAt(index_) != '=') {
            	handler_.fatalError(new RuntimeException("Illegal character not '=' after attribute name at " + index_));
            }
            //Read =
            index_++;
            //= S*
            skipConsecutiveWhitespaces();
            //"value1"
            if(data_.charAt(index_) != '"') {
            	handler_.fatalError(new RuntimeException("Illegal character not '\"' at starting of attribute value at " + index_));
            }
            //Read "
            index_++;
            String attributeValue = "";
            //Read attribute value
            while (data_.charAt(index_) != '"') {
            	if(validateCharInAttributeValue(data_.charAt(index_))){
            		attributeValue += data_.charAt(index_);
            		index_++;
            	} else {
            		handler_.fatalError(new RuntimeException("Illegal character '<' or '\"' inside the attribute value at " + index_));
            	}
            }
            
            //Read "
            index_++;
            
            attributes.addAttribute(attributeName, attributeValue);
            //Remove any space after attribute pair like  attr1="value1"    attr2="value2"
            skipConsecutiveWhitespaces();
        }
        
        // Read ending >
        index_++;
        
        //if no attributes are present then set attributes to null
        if (attributes.getLength() == 0) {
        	attributes = null;
        }
        handler_.startElement(name, attributes);

        // return this element's name, for later comparision
        // with an end tag
        return name;
    }


	/**
	 * @return the current name of the tag 
	 * 
	 * common method for extracting the tag name from both startTag and endTag
	 */
	private String readNameOfTag() {
		// start name from scratch
        String name = "";
		
		while (data_.charAt(index_) != '>' && isNotWhiteSpace()) {
        	if(validateCharInName(data_.charAt(index_))){
        		name += data_.charAt(index_);
        		index_++;
        	} else {
        		handler_.fatalError(new RuntimeException("Illegal character inside the name of a tag at " + index_));
        	}
        }
		return name;
	}
    
    
    /**
     * @param charToExamine
     * 
     * AttValue can be zero or more characters excluding '<' and '"'
     * 
     * @return true if charToExamine is in {'<', '"'}
     */
    private boolean validateCharInAttributeValue(char charToExamine) {
		return charToExamine != '<' && charToExamine != '"';
	}


	//Name is now one or more letters, numbers, hyphens, periods, and underscores
    private boolean validateCharInName(char charToExamine) {
    	return Character.isLetter(charToExamine) 
    			|| Character.isDigit(charToExamine) 
    			|| charToExamine == '-' 
    			|| charToExamine == '.' 
    			|| charToExamine == '_';
    }


	protected boolean isNotWhiteSpace() {
		return isNotWhiteSpace(data_.charAt(index_));
	}


	
	/**
	 * @param charToExamine
	 * @return true if chatToExamine is a non-whitespace character or else false
	 */
	private boolean isNotWhiteSpace(char charToExamine) {
		return !Character.isWhitespace(charToExamine);
	}


	/**
     * Parses character data.
     */
    protected void readText()
    {
        // start character data from scratch
        String content = "";

        // accumulate characters until next tag
        while (data_.charAt(index_) != '<')
        {
            content += data_.charAt(index_);
            index_++;
        }

        // pass this SAX event to handler
        handler_.characters(content);
    }
}
